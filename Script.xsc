/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of Script.xs. Do not edit this file, edit Script.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Script.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <stdio.h>
#include <ctype.h>
#include <errno.h>

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <assert.h>
#include <ccoin/util.h>
#include <ccoin/buffer.h>
#include <ccoin/script.h>
#include <ccoin/core.h>
#include <ccoin/mbr.h>
#include <ccoin/message.h>
//#include <ccoin/compat.h>

////// extra

SV* picocoin_returnblankSV(void){
	//SV* ans_sv = newSVpv("",1);
	//return ans_sv;
	return &PL_sv_undef;
}


int dummy2(int x) {
	return x;
}

static bool is_digitstr(const char *s)
{
	if (*s == '-')
		s++;

	while (*s) {
		if (!isdigit(*s))
			return false;
		s++;
	}

	return true;
}

static char **strsplit_set(const char *s, const char *delim)
{
	// init delimiter lookup table
	const char *stmp;
	bool is_delim[256];
	memset(&is_delim, 0, sizeof(is_delim));

	stmp = delim;
	while (*stmp) {
		is_delim[(unsigned char)*stmp] = true;
		stmp++;
	}

	bool in_str = true;
	parr *pa = parr_new(0, free);
	cstring *cs = cstr_new(NULL);
	if (!pa || !cs)
		goto err_out;

	while (*s) {
		unsigned char ch = (unsigned char) *s;
		if (is_delim[ch]) {
			if (in_str) {
				in_str = false;
				parr_add(pa, cs->str);

				cstr_free(cs, false);
				cs = cstr_new(NULL);
				if (!cs)
					goto err_out;
			}
		} else {
			in_str = true;
			if (!cstr_append_c(cs, ch))
				goto err_out;
		}
		s++;
	}

	parr_add(pa, cs->str);
	cstr_free(cs, false);

	parr_add(pa, NULL);

<<<<<<< HEAD
/*char* serializeP2SH(char* scriptstring){
	CBScript * script = CBNewScriptP2SHOutput(CBNewScriptFromString(scriptstring));
	return CBScript_obj_to_serializeddata(script);
}*/



char* addressToHex(char* addressString){
    CBByteArray * addrStr = CBNewByteArrayFromString(addressString, true);

    CBAddress * addr = CBNewAddressFromString(addrStr, false);
    if(addr == NULL)
    	return "";
    
    uint8_t * pubKeyHash = CBByteArrayGetData(CBGetByteArray(addr)) + 1;
    
    int prefix = (int) CBChecksumBytesGetPrefix(addr);
    
    
    CBScript *script;
    char *answer;
    
    if(prefix == 0x00){
    	return bytearray_to_hexstring(CBGetByteArray(addr),CBGetByteArray(addr)->length);
    	//return "p2pkh";
    }
    else if(prefix == 0x05){
    	// see CBInitChecksumBytesFromString for details
    	return bytearray_to_hexstring(CBGetByteArray(addr),CBGetByteArray(addr)->length);
	
    	uint8_t hash[32];
		uint32_t keylength = 20;
		//CBSha256(pubKeyHash, keylength, hash);

		
		script = (CBScript *) CBNewByteArrayOfSize(
			1 + 1 + keylength + 1
		);
		CBByteArraySetByte(script, 0, CB_SCRIPT_OP_HASH160);
		// indicates 20 bytes follow, see https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki
		CBByteArraySetByte(script, 1, 0x14);
		CBByteArraySetBytes(script, 2, pubKeyHash, keylength);
		CBByteArraySetByte(script,
			2 + keylength , 
			CB_SCRIPT_OP_EQUAL
		);
    	
    }
    else{
    	return "unknown";
    }
    //return bytearray_to_hexstring(CBGetByteArray(addr), 20);
    //CBFreeAddress(addr);
    return CBScript_obj_to_serializeddata(script);
	//return "crap";
}
